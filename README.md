Есть два способа запуска. Первый с помощью docker compose starter, второй через полный запуск в контейнерах
1)Первый способ запуска
./gradlew bootRun


2)Второй способ запуска 
./gradlew bootJar
docker-compose -f full-compose.yaml up


Open Api
http://localhost:8080/swagger/swagger-ui/index.html#/
Порядок действий 
1) создать пользователя
2) login
3) вставка токен
4) дальнейшие действия


Тестовые клиенты с паролями Qwerty123
1) Testuser 
2) Testusersecond
Соответсвенно счета
1) 22222222-2222-2222-2222-222222222222 500
2) 33333333-3333-3333-3333-333333333333 600

Тестовые даты для двух транзакций
1) 2024-04-01T10:00:00
2) 2024-04-02T15:30:00


Описание решений
1) ручная конфигурация security, без oauth2 по требованию
2) слабое изолирование видимости данных, для упрощения контрактов и для требования получаения всех трансферов
3) Логика трансфероф через блокировки записей, чтоб не усложнять логику через изоляции и повторы или через Optimistic version
3.5) по идее можно было как то реализовать через ассинхронный процесс трансфера с некой логикой TransactionOutbox,
где была бы таблица запросов, в которой приниимается заявка, а потом условный планировщик пытался бы провести операцию и
и сохронял бы статусы обработок. По идее мы блокируем запись account, потому если мы работаем с appUser тоже с pessimistic,
то они могут на друг друга влиять, потому при дальнейшем имеет смысл возможно убрать отношения или сделать через другую реализацию,
например через ту же изоляцию
4) Unit тестов нет, но интеграционные тесты покрывают в целом end to end логику, потому скипнул
5) У пользователя пока с счетами отношение toOne
6) Оставльные моменты которые можно развить выделены в //TODO
7) Запросы на получение коллекций реализованы через Page, так как в целом так лучше :-)
